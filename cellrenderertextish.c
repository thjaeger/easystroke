/* cellrenderertextish.c generated by valac 0.40.23, the Vala compiler
 * generated from cellrenderertextish.vala, do not modify */

/* compile with  valac -c cellrenderertextish.vala --pkg gtk+-3.0 -C -H cellrenderertextish.h */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gdk/gdk.h>
#include <glib/gi18n-lib.h>


#define TYPE_CELL_RENDERER_TEXTISH (cell_renderer_textish_get_type ())
#define CELL_RENDERER_TEXTISH(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CELL_RENDERER_TEXTISH, CellRendererTextish))
#define CELL_RENDERER_TEXTISH_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CELL_RENDERER_TEXTISH, CellRendererTextishClass))
#define IS_CELL_RENDERER_TEXTISH(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CELL_RENDERER_TEXTISH))
#define IS_CELL_RENDERER_TEXTISH_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CELL_RENDERER_TEXTISH))
#define CELL_RENDERER_TEXTISH_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CELL_RENDERER_TEXTISH, CellRendererTextishClass))

typedef struct _CellRendererTextish CellRendererTextish;
typedef struct _CellRendererTextishClass CellRendererTextishClass;
typedef struct _CellRendererTextishPrivate CellRendererTextishPrivate;
typedef enum  {
	CELL_RENDERER_TEXTISH_MODE_Text,
	CELL_RENDERER_TEXTISH_MODE_Key,
	CELL_RENDERER_TEXTISH_MODE_Popup,
	CELL_RENDERER_TEXTISH_MODE_Combo
} CellRendererTextishMode;


#define CELL_RENDERER_TEXTISH_TYPE_MODE (cell_renderer_textish_mode_get_type ())
enum  {
	CELL_RENDERER_TEXTISH_0_PROPERTY,
	CELL_RENDERER_TEXTISH_NUM_PROPERTIES
};
static GParamSpec* cell_renderer_textish_properties[CELL_RENDERER_TEXTISH_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_CELL_EDITABLE_ACCEL (cell_editable_accel_get_type ())
#define CELL_EDITABLE_ACCEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CELL_EDITABLE_ACCEL, CellEditableAccel))
#define CELL_EDITABLE_ACCEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CELL_EDITABLE_ACCEL, CellEditableAccelClass))
#define IS_CELL_EDITABLE_ACCEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CELL_EDITABLE_ACCEL))
#define IS_CELL_EDITABLE_ACCEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CELL_EDITABLE_ACCEL))
#define CELL_EDITABLE_ACCEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CELL_EDITABLE_ACCEL, CellEditableAccelClass))

typedef struct _CellEditableAccel CellEditableAccel;
typedef struct _CellEditableAccelClass CellEditableAccelClass;

#define TYPE_CELL_EDITABLE_COMBO (cell_editable_combo_get_type ())
#define CELL_EDITABLE_COMBO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CELL_EDITABLE_COMBO, CellEditableCombo))
#define CELL_EDITABLE_COMBO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CELL_EDITABLE_COMBO, CellEditableComboClass))
#define IS_CELL_EDITABLE_COMBO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CELL_EDITABLE_COMBO))
#define IS_CELL_EDITABLE_COMBO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CELL_EDITABLE_COMBO))
#define CELL_EDITABLE_COMBO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CELL_EDITABLE_COMBO, CellEditableComboClass))

typedef struct _CellEditableCombo CellEditableCombo;
typedef struct _CellEditableComboClass CellEditableComboClass;

#define TYPE_CELL_EDITABLE_DUMMY (cell_editable_dummy_get_type ())
#define CELL_EDITABLE_DUMMY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CELL_EDITABLE_DUMMY, CellEditableDummy))
#define CELL_EDITABLE_DUMMY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CELL_EDITABLE_DUMMY, CellEditableDummyClass))
#define IS_CELL_EDITABLE_DUMMY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CELL_EDITABLE_DUMMY))
#define IS_CELL_EDITABLE_DUMMY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CELL_EDITABLE_DUMMY))
#define CELL_EDITABLE_DUMMY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CELL_EDITABLE_DUMMY, CellEditableDummyClass))

typedef struct _CellEditableDummy CellEditableDummy;
typedef struct _CellEditableDummyClass CellEditableDummyClass;
enum  {
	CELL_RENDERER_TEXTISH_KEY_EDITED_SIGNAL,
	CELL_RENDERER_TEXTISH_COMBO_EDITED_SIGNAL,
	CELL_RENDERER_TEXTISH_NUM_SIGNALS
};
static guint cell_renderer_textish_signals[CELL_RENDERER_TEXTISH_NUM_SIGNALS] = {0};
typedef struct _CellEditableDummyPrivate CellEditableDummyPrivate;
enum  {
	CELL_EDITABLE_DUMMY_0_PROPERTY,
	CELL_EDITABLE_DUMMY_EDITING_CANCELED_PROPERTY,
	CELL_EDITABLE_DUMMY_NUM_PROPERTIES
};
static GParamSpec* cell_editable_dummy_properties[CELL_EDITABLE_DUMMY_NUM_PROPERTIES];
typedef struct _CellEditableAccelPrivate CellEditableAccelPrivate;
enum  {
	CELL_EDITABLE_ACCEL_0_PROPERTY,
	CELL_EDITABLE_ACCEL_EDITING_CANCELED_PROPERTY,
	CELL_EDITABLE_ACCEL_NUM_PROPERTIES
};
static GParamSpec* cell_editable_accel_properties[CELL_EDITABLE_ACCEL_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _CellEditableComboPrivate CellEditableComboPrivate;
enum  {
	CELL_EDITABLE_COMBO_0_PROPERTY,
	CELL_EDITABLE_COMBO_NUM_PROPERTIES
};
static GParamSpec* cell_editable_combo_properties[CELL_EDITABLE_COMBO_NUM_PROPERTIES];
typedef struct _Block1Data Block1Data;

struct _CellRendererTextish {
	GtkCellRendererText parent_instance;
	CellRendererTextishPrivate * priv;
	CellRendererTextishMode mode;
	gchar** items;
	gint items_length1;
};

struct _CellRendererTextishClass {
	GtkCellRendererTextClass parent_class;
};

struct _CellRendererTextishPrivate {
	GtkCellEditable* cell;
};

struct _CellEditableDummy {
	GtkEventBox parent_instance;
	CellEditableDummyPrivate * priv;
};

struct _CellEditableDummyClass {
	GtkEventBoxClass parent_class;
	void (*start_editing) (CellEditableDummy* self, GdkEvent* event);
};

struct _CellEditableDummyPrivate {
	gboolean _editing_canceled;
};

struct _CellEditableAccel {
	GtkEventBox parent_instance;
	CellEditableAccelPrivate * priv;
};

struct _CellEditableAccelClass {
	GtkEventBoxClass parent_class;
	void (*start_editing) (CellEditableAccel* self, GdkEvent* event);
};

struct _CellEditableAccelPrivate {
	gboolean _editing_canceled;
	CellRendererTextish* parent;
	gchar* path;
};

struct _CellEditableCombo {
	GtkComboBoxText parent_instance;
	CellEditableComboPrivate * priv;
};

struct _CellEditableComboClass {
	GtkComboBoxTextClass parent_class;
	void (*start_editing) (CellEditableCombo* self, GdkEvent* event);
};

struct _CellEditableComboPrivate {
	CellRendererTextish* parent;
	gchar* path;
};

struct _Block1Data {
	int _ref_count_;
	CellEditableCombo* self;
	CellRendererTextish* parent;
	gchar* path;
};


static gpointer cell_renderer_textish_parent_class = NULL;
static gpointer cell_editable_dummy_parent_class = NULL;
static GtkCellEditableIface * cell_editable_dummy_gtk_cell_editable_parent_iface = NULL;
static gpointer cell_editable_accel_parent_class = NULL;
static GtkCellEditableIface * cell_editable_accel_gtk_cell_editable_parent_iface = NULL;
static gpointer cell_editable_combo_parent_class = NULL;
static GtkCellEditableIface * cell_editable_combo_gtk_cell_editable_parent_iface = NULL;

GType cell_renderer_textish_get_type (void) G_GNUC_CONST;
GType cell_renderer_textish_mode_get_type (void) G_GNUC_CONST;
#define CELL_RENDERER_TEXTISH_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_CELL_RENDERER_TEXTISH, CellRendererTextishPrivate))
CellRendererTextish* cell_renderer_textish_new (void);
CellRendererTextish* cell_renderer_textish_construct (GType object_type);
CellRendererTextish* cell_renderer_textish_new_with_items (gchar** items,
                                                           int items_length1);
CellRendererTextish* cell_renderer_textish_construct_with_items (GType object_type,
                                                                 gchar** items,
                                                                 int items_length1);
static gchar** _vala_array_dup1 (gchar** self,
                          int length);
static GtkCellEditable* cell_renderer_textish_real_start_editing (GtkCellRenderer* base,
                                                           GdkEvent* event,
                                                           GtkWidget* widget,
                                                           const gchar* path,
                                                           GdkRectangle* background_area,
                                                           GdkRectangle* cell_area,
                                                           GtkCellRendererState flags);
CellEditableAccel* cell_editable_accel_new (CellRendererTextish* parent,
                                            const gchar* path,
                                            GtkWidget* widget);
CellEditableAccel* cell_editable_accel_construct (GType object_type,
                                                  CellRendererTextish* parent,
                                                  const gchar* path,
                                                  GtkWidget* widget);
GType cell_editable_accel_get_type (void) G_GNUC_CONST;
CellEditableCombo* cell_editable_combo_new (CellRendererTextish* parent,
                                            const gchar* path,
                                            GtkWidget* widget,
                                            gchar** items,
                                            int items_length1);
CellEditableCombo* cell_editable_combo_construct (GType object_type,
                                                  CellRendererTextish* parent,
                                                  const gchar* path,
                                                  GtkWidget* widget,
                                                  gchar** items,
                                                  int items_length1);
GType cell_editable_combo_get_type (void) G_GNUC_CONST;
CellEditableDummy* cell_editable_dummy_new (void);
CellEditableDummy* cell_editable_dummy_construct (GType object_type);
GType cell_editable_dummy_get_type (void) G_GNUC_CONST;
static void g_cclosure_user_marshal_VOID__STRING_FLAGS_UINT (GClosure * closure,
                                                      GValue * return_value,
                                                      guint n_param_values,
                                                      const GValue * param_values,
                                                      gpointer invocation_hint,
                                                      gpointer marshal_data);
static void g_cclosure_user_marshal_VOID__STRING_UINT (GClosure * closure,
                                                GValue * return_value,
                                                guint n_param_values,
                                                const GValue * param_values,
                                                gpointer invocation_hint,
                                                gpointer marshal_data);
static void cell_renderer_textish_finalize (GObject * obj);
#define CELL_EDITABLE_DUMMY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_CELL_EDITABLE_DUMMY, CellEditableDummyPrivate))
void cell_editable_dummy_start_editing (CellEditableDummy* self,
                                        GdkEvent* event);
static void cell_editable_dummy_real_start_editing (CellEditableDummy* self,
                                             GdkEvent* event);
gboolean cell_editable_dummy_get_editing_canceled (CellEditableDummy* self);
void cell_editable_dummy_set_editing_canceled (CellEditableDummy* self,
                                               gboolean value);
static void cell_editable_dummy_finalize (GObject * obj);
static void _vala_cell_editable_dummy_get_property (GObject * object,
                                             guint property_id,
                                             GValue * value,
                                             GParamSpec * pspec);
static void _vala_cell_editable_dummy_set_property (GObject * object,
                                             guint property_id,
                                             const GValue * value,
                                             GParamSpec * pspec);
#define CELL_EDITABLE_ACCEL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_CELL_EDITABLE_ACCEL, CellEditableAccelPrivate))
static void cell_editable_accel_on_editing_done (CellEditableAccel* self);
static void _cell_editable_accel_on_editing_done_gtk_cell_editable_editing_done (GtkCellEditable* _sender,
                                                                          gpointer self);
void cell_editable_accel_start_editing (CellEditableAccel* self,
                                        GdkEvent* event);
static void cell_editable_accel_real_start_editing (CellEditableAccel* self,
                                             GdkEvent* event);
static gboolean cell_editable_accel_on_key (CellEditableAccel* self,
                                     GdkEventKey* event);
static gboolean _cell_editable_accel_on_key_gtk_widget_key_press_event (GtkWidget* _sender,
                                                                 GdkEventKey* event,
                                                                 gpointer self);
gboolean cell_editable_accel_get_editing_canceled (CellEditableAccel* self);
void cell_editable_accel_set_editing_canceled (CellEditableAccel* self,
                                               gboolean value);
static void cell_editable_accel_finalize (GObject * obj);
static void _vala_cell_editable_accel_get_property (GObject * object,
                                             guint property_id,
                                             GValue * value,
                                             GParamSpec * pspec);
static void _vala_cell_editable_accel_set_property (GObject * object,
                                             guint property_id,
                                             const GValue * value,
                                             GParamSpec * pspec);
#define CELL_EDITABLE_COMBO_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_CELL_EDITABLE_COMBO, CellEditableComboPrivate))
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static void __lambda4_ (Block1Data* _data1_);
static void ___lambda4__gtk_combo_box_changed (GtkComboBox* _sender,
                                        gpointer self);
void cell_editable_combo_start_editing (CellEditableCombo* self,
                                        GdkEvent* event);
static void cell_editable_combo_real_start_editing (CellEditableCombo* self,
                                             GdkEvent* event);
static void cell_editable_combo_finalize (GObject * obj);
static void _vala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);


GType
cell_renderer_textish_mode_get_type (void)
{
	static volatile gsize cell_renderer_textish_mode_type_id__volatile = 0;
	if (g_once_init_enter (&cell_renderer_textish_mode_type_id__volatile)) {
		static const GEnumValue values[] = {{CELL_RENDERER_TEXTISH_MODE_Text, "CELL_RENDERER_TEXTISH_MODE_Text", "text"}, {CELL_RENDERER_TEXTISH_MODE_Key, "CELL_RENDERER_TEXTISH_MODE_Key", "key"}, {CELL_RENDERER_TEXTISH_MODE_Popup, "CELL_RENDERER_TEXTISH_MODE_Popup", "popup"}, {CELL_RENDERER_TEXTISH_MODE_Combo, "CELL_RENDERER_TEXTISH_MODE_Combo", "combo"}, {0, NULL, NULL}};
		GType cell_renderer_textish_mode_type_id;
		cell_renderer_textish_mode_type_id = g_enum_register_static ("CellRendererTextishMode", values);
		g_once_init_leave (&cell_renderer_textish_mode_type_id__volatile, cell_renderer_textish_mode_type_id);
	}
	return cell_renderer_textish_mode_type_id__volatile;
}


CellRendererTextish*
cell_renderer_textish_construct (GType object_type)
{
	CellRendererTextish * self = NULL;
	self = (CellRendererTextish*) g_object_new (object_type, NULL);
	self->mode = CELL_RENDERER_TEXTISH_MODE_Text;
	_g_object_unref0 (self->priv->cell);
	self->priv->cell = NULL;
	self->items = (_vala_array_free (self->items, self->items_length1, (GDestroyNotify) g_free), NULL);
	self->items = NULL;
	self->items_length1 = 0;
	return self;
}


CellRendererTextish*
cell_renderer_textish_new (void)
{
	return cell_renderer_textish_construct (TYPE_CELL_RENDERER_TEXTISH);
}


static gchar**
_vala_array_dup1 (gchar** self,
                  int length)
{
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


CellRendererTextish*
cell_renderer_textish_construct_with_items (GType object_type,
                                            gchar** items,
                                            int items_length1)
{
	CellRendererTextish * self = NULL;
	gchar** _tmp0_;
	gint _tmp0__length1;
	self = (CellRendererTextish*) g_object_new (object_type, NULL);
	self->mode = CELL_RENDERER_TEXTISH_MODE_Text;
	_g_object_unref0 (self->priv->cell);
	self->priv->cell = NULL;
	_tmp0_ = (items != NULL) ? _vala_array_dup1 (items, items_length1) : ((gpointer) items);
	_tmp0__length1 = items_length1;
	self->items = (_vala_array_free (self->items, self->items_length1, (GDestroyNotify) g_free), NULL);
	self->items = _tmp0_;
	self->items_length1 = _tmp0__length1;
	return self;
}


CellRendererTextish*
cell_renderer_textish_new_with_items (gchar** items,
                                      int items_length1)
{
	return cell_renderer_textish_construct_with_items (TYPE_CELL_RENDERER_TEXTISH, items, items_length1);
}


static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}


static GtkCellEditable*
cell_renderer_textish_real_start_editing (GtkCellRenderer* base,
                                          GdkEvent* event,
                                          GtkWidget* widget,
                                          const gchar* path,
                                          GdkRectangle* background_area,
                                          GdkRectangle* cell_area,
                                          GtkCellRendererState flags)
{
	CellRendererTextish * self;
	GtkCellEditable* result = NULL;
	gboolean _tmp0_;
	gboolean _tmp1_;
	CellRendererTextishMode _tmp3_;
	GtkCellEditable* _tmp12_;
	self = (CellRendererTextish*) base;
	g_return_val_if_fail (widget != NULL, NULL);
	g_return_val_if_fail (path != NULL, NULL);
	g_return_val_if_fail (background_area != NULL, NULL);
	g_return_val_if_fail (cell_area != NULL, NULL);
	_g_object_unref0 (self->priv->cell);
	self->priv->cell = NULL;
	g_object_get ((GtkCellRendererText*) self, "editable", &_tmp0_, NULL);
	_tmp1_ = _tmp0_;
	if (!_tmp1_) {
		GtkCellEditable* _tmp2_;
		_tmp2_ = self->priv->cell;
		result = _tmp2_;
		return result;
	}
	_tmp3_ = self->mode;
	switch (_tmp3_) {
		case CELL_RENDERER_TEXTISH_MODE_Text:
		{
			GdkRectangle _tmp4_;
			GdkRectangle _tmp5_;
			GtkCellEditable* _tmp6_;
			GtkCellEditable* _tmp7_;
			_tmp4_ = *background_area;
			_tmp5_ = *cell_area;
			_tmp6_ = GTK_CELL_RENDERER_CLASS (cell_renderer_textish_parent_class)->start_editing ((GtkCellRenderer*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_cell_renderer_text_get_type (), GtkCellRendererText), event, widget, path, &_tmp4_, &_tmp5_, flags);
			_tmp7_ = _g_object_ref0 (_tmp6_);
			_g_object_unref0 (self->priv->cell);
			self->priv->cell = _tmp7_;
			break;
		}
		case CELL_RENDERER_TEXTISH_MODE_Key:
		{
			CellEditableAccel* _tmp8_;
			_tmp8_ = cell_editable_accel_new (self, path, widget);
			g_object_ref_sink (_tmp8_);
			_g_object_unref0 (self->priv->cell);
			self->priv->cell = (GtkCellEditable*) _tmp8_;
			break;
		}
		case CELL_RENDERER_TEXTISH_MODE_Combo:
		{
			gchar** _tmp9_;
			gint _tmp9__length1;
			CellEditableCombo* _tmp10_;
			_tmp9_ = self->items;
			_tmp9__length1 = self->items_length1;
			_tmp10_ = cell_editable_combo_new (self, path, widget, _tmp9_, _tmp9__length1);
			g_object_ref_sink (_tmp10_);
			_g_object_unref0 (self->priv->cell);
			self->priv->cell = (GtkCellEditable*) _tmp10_;
			break;
		}
		case CELL_RENDERER_TEXTISH_MODE_Popup:
		{
			CellEditableDummy* _tmp11_;
			_tmp11_ = cell_editable_dummy_new ();
			g_object_ref_sink (_tmp11_);
			_g_object_unref0 (self->priv->cell);
			self->priv->cell = (GtkCellEditable*) _tmp11_;
			break;
		}
		default:
		break;
	}
	_tmp12_ = self->priv->cell;
	result = _tmp12_;
	return result;
}


static void
g_cclosure_user_marshal_VOID__STRING_FLAGS_UINT (GClosure * closure,
                                                 GValue * return_value,
                                                 guint n_param_values,
                                                 const GValue * param_values,
                                                 gpointer invocation_hint,
                                                 gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__STRING_FLAGS_UINT) (gpointer data1, const char* arg_1, guint arg_2, guint arg_3, gpointer data2);
	register GMarshalFunc_VOID__STRING_FLAGS_UINT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 4);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_FLAGS_UINT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_flags (param_values + 2), g_value_get_uint (param_values + 3), data2);
}


static void
g_cclosure_user_marshal_VOID__STRING_UINT (GClosure * closure,
                                           GValue * return_value,
                                           guint n_param_values,
                                           const GValue * param_values,
                                           gpointer invocation_hint,
                                           gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__STRING_UINT) (gpointer data1, const char* arg_1, guint arg_2, gpointer data2);
	register GMarshalFunc_VOID__STRING_UINT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_UINT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_uint (param_values + 2), data2);
}


static void
cell_renderer_textish_class_init (CellRendererTextishClass * klass)
{
	cell_renderer_textish_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (CellRendererTextishPrivate));
	((GtkCellRendererClass *) klass)->start_editing = (GtkCellEditable* (*) (GtkCellRenderer*, GdkEvent*, GtkWidget*, const gchar*, GdkRectangle*, GdkRectangle*, GtkCellRendererState)) cell_renderer_textish_real_start_editing;
	G_OBJECT_CLASS (klass)->finalize = cell_renderer_textish_finalize;
	cell_renderer_textish_signals[CELL_RENDERER_TEXTISH_KEY_EDITED_SIGNAL] = g_signal_new ("key-edited", TYPE_CELL_RENDERER_TEXTISH, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_FLAGS_UINT, G_TYPE_NONE, 3, G_TYPE_STRING, gdk_modifier_type_get_type (), G_TYPE_UINT);
	cell_renderer_textish_signals[CELL_RENDERER_TEXTISH_COMBO_EDITED_SIGNAL] = g_signal_new ("combo-edited", TYPE_CELL_RENDERER_TEXTISH, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_UINT, G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_UINT);
}


static void
cell_renderer_textish_instance_init (CellRendererTextish * self)
{
	self->priv = CELL_RENDERER_TEXTISH_GET_PRIVATE (self);
}


static void
cell_renderer_textish_finalize (GObject * obj)
{
	CellRendererTextish * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CELL_RENDERER_TEXTISH, CellRendererTextish);
	self->items = (_vala_array_free (self->items, self->items_length1, (GDestroyNotify) g_free), NULL);
	_g_object_unref0 (self->priv->cell);
	G_OBJECT_CLASS (cell_renderer_textish_parent_class)->finalize (obj);
}


GType
cell_renderer_textish_get_type (void)
{
	static volatile gsize cell_renderer_textish_type_id__volatile = 0;
	if (g_once_init_enter (&cell_renderer_textish_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (CellRendererTextishClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) cell_renderer_textish_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (CellRendererTextish), 0, (GInstanceInitFunc) cell_renderer_textish_instance_init, NULL };
		GType cell_renderer_textish_type_id;
		cell_renderer_textish_type_id = g_type_register_static (gtk_cell_renderer_text_get_type (), "CellRendererTextish", &g_define_type_info, 0);
		g_once_init_leave (&cell_renderer_textish_type_id__volatile, cell_renderer_textish_type_id);
	}
	return cell_renderer_textish_type_id__volatile;
}


static void
cell_editable_dummy_real_start_editing (CellEditableDummy* self,
                                        GdkEvent* event)
{
	gtk_cell_editable_editing_done ((GtkCellEditable*) self);
	gtk_cell_editable_remove_widget ((GtkCellEditable*) self);
}


void
cell_editable_dummy_start_editing (CellEditableDummy* self,
                                   GdkEvent* event)
{
	g_return_if_fail (self != NULL);
	CELL_EDITABLE_DUMMY_GET_CLASS (self)->start_editing (self, event);
}


CellEditableDummy*
cell_editable_dummy_construct (GType object_type)
{
	CellEditableDummy * self = NULL;
	self = (CellEditableDummy*) g_object_new (object_type, NULL);
	return self;
}


CellEditableDummy*
cell_editable_dummy_new (void)
{
	return cell_editable_dummy_construct (TYPE_CELL_EDITABLE_DUMMY);
}


gboolean
cell_editable_dummy_get_editing_canceled (CellEditableDummy* self)
{
	gboolean result;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_editing_canceled;
	result = _tmp0_;
	return result;
}


void
cell_editable_dummy_set_editing_canceled (CellEditableDummy* self,
                                          gboolean value)
{
	g_return_if_fail (self != NULL);
	if (cell_editable_dummy_get_editing_canceled (self) != value) {
		self->priv->_editing_canceled = value;
		g_object_notify_by_pspec ((GObject *) self, cell_editable_dummy_properties[CELL_EDITABLE_DUMMY_EDITING_CANCELED_PROPERTY]);
	}
}


static void
cell_editable_dummy_class_init (CellEditableDummyClass * klass)
{
	cell_editable_dummy_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (CellEditableDummyPrivate));
	((CellEditableDummyClass *) klass)->start_editing = (void (*) (CellEditableDummy*, GdkEvent*)) cell_editable_dummy_real_start_editing;
	G_OBJECT_CLASS (klass)->get_property = _vala_cell_editable_dummy_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_cell_editable_dummy_set_property;
	G_OBJECT_CLASS (klass)->finalize = cell_editable_dummy_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), CELL_EDITABLE_DUMMY_EDITING_CANCELED_PROPERTY, cell_editable_dummy_properties[CELL_EDITABLE_DUMMY_EDITING_CANCELED_PROPERTY] = g_param_spec_boolean ("editing-canceled", "editing-canceled", "editing-canceled", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void
cell_editable_dummy_gtk_cell_editable_interface_init (GtkCellEditableIface * iface)
{
	cell_editable_dummy_gtk_cell_editable_parent_iface = g_type_interface_peek_parent (iface);
	iface->start_editing = (void (*) (GtkCellEditable*, GdkEvent*)) cell_editable_dummy_start_editing;
}


static void
cell_editable_dummy_instance_init (CellEditableDummy * self)
{
	self->priv = CELL_EDITABLE_DUMMY_GET_PRIVATE (self);
}


static void
cell_editable_dummy_finalize (GObject * obj)
{
	CellEditableDummy * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CELL_EDITABLE_DUMMY, CellEditableDummy);
	G_OBJECT_CLASS (cell_editable_dummy_parent_class)->finalize (obj);
}


GType
cell_editable_dummy_get_type (void)
{
	static volatile gsize cell_editable_dummy_type_id__volatile = 0;
	if (g_once_init_enter (&cell_editable_dummy_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (CellEditableDummyClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) cell_editable_dummy_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (CellEditableDummy), 0, (GInstanceInitFunc) cell_editable_dummy_instance_init, NULL };
		static const GInterfaceInfo gtk_cell_editable_info = { (GInterfaceInitFunc) cell_editable_dummy_gtk_cell_editable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType cell_editable_dummy_type_id;
		cell_editable_dummy_type_id = g_type_register_static (gtk_event_box_get_type (), "CellEditableDummy", &g_define_type_info, 0);
		g_type_add_interface_static (cell_editable_dummy_type_id, gtk_cell_editable_get_type (), &gtk_cell_editable_info);
		g_once_init_leave (&cell_editable_dummy_type_id__volatile, cell_editable_dummy_type_id);
	}
	return cell_editable_dummy_type_id__volatile;
}


static void
_vala_cell_editable_dummy_get_property (GObject * object,
                                        guint property_id,
                                        GValue * value,
                                        GParamSpec * pspec)
{
	CellEditableDummy * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_CELL_EDITABLE_DUMMY, CellEditableDummy);
	switch (property_id) {
		case CELL_EDITABLE_DUMMY_EDITING_CANCELED_PROPERTY:
		g_value_set_boolean (value, cell_editable_dummy_get_editing_canceled (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void
_vala_cell_editable_dummy_set_property (GObject * object,
                                        guint property_id,
                                        const GValue * value,
                                        GParamSpec * pspec)
{
	CellEditableDummy * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_CELL_EDITABLE_DUMMY, CellEditableDummy);
	switch (property_id) {
		case CELL_EDITABLE_DUMMY_EDITING_CANCELED_PROPERTY:
		cell_editable_dummy_set_editing_canceled (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void
_cell_editable_accel_on_editing_done_gtk_cell_editable_editing_done (GtkCellEditable* _sender,
                                                                     gpointer self)
{
	cell_editable_accel_on_editing_done ((CellEditableAccel*) self);
}


CellEditableAccel*
cell_editable_accel_construct (GType object_type,
                               CellRendererTextish* parent,
                               const gchar* path,
                               GtkWidget* widget)
{
	CellEditableAccel * self = NULL;
	CellRendererTextish* _tmp0_;
	gchar* _tmp1_;
	GtkLabel* label = NULL;
	GtkLabel* _tmp2_;
	GtkStyleContext* _tmp3_;
	GdkRGBA _tmp4_ = {0};
	GtkStyleContext* _tmp5_;
	GdkRGBA _tmp6_ = {0};
	g_return_val_if_fail (parent != NULL, NULL);
	g_return_val_if_fail (path != NULL, NULL);
	g_return_val_if_fail (widget != NULL, NULL);
	self = (CellEditableAccel*) g_object_new (object_type, NULL);
	_tmp0_ = _g_object_ref0 (parent);
	_g_object_unref0 (self->priv->parent);
	self->priv->parent = _tmp0_;
	_tmp1_ = g_strdup (path);
	_g_free0 (self->priv->path);
	self->priv->path = _tmp1_;
	g_signal_connect_object ((GtkCellEditable*) self, "editing-done", (GCallback) _cell_editable_accel_on_editing_done_gtk_cell_editable_editing_done, self, 0);
	_tmp2_ = (GtkLabel*) gtk_label_new (_ ("Key combination..."));
	g_object_ref_sink (_tmp2_);
	label = _tmp2_;
	gtk_misc_set_alignment ((GtkMisc*) label, 0.0f, 0.5f);
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) label);
	_tmp3_ = gtk_widget_get_style_context (widget);
	gtk_style_context_get_background_color (_tmp3_, GTK_STATE_FLAG_SELECTED, &_tmp4_);
	gtk_widget_override_background_color ((GtkWidget*) self, GTK_STATE_FLAG_NORMAL, &_tmp4_);
	_tmp5_ = gtk_widget_get_style_context (widget);
	gtk_style_context_get_color (_tmp5_, GTK_STATE_FLAG_SELECTED, &_tmp6_);
	gtk_widget_override_color ((GtkWidget*) label, GTK_STATE_FLAG_NORMAL, &_tmp6_);
	gtk_widget_show_all ((GtkWidget*) self);
	_g_object_unref0 (label);
	return self;
}


CellEditableAccel*
cell_editable_accel_new (CellRendererTextish* parent,
                         const gchar* path,
                         GtkWidget* widget)
{
	return cell_editable_accel_construct (TYPE_CELL_EDITABLE_ACCEL, parent, path, widget);
}


static gboolean
_cell_editable_accel_on_key_gtk_widget_key_press_event (GtkWidget* _sender,
                                                        GdkEventKey* event,
                                                        gpointer self)
{
	gboolean result;
	result = cell_editable_accel_on_key ((CellEditableAccel*) self, event);
	return result;
}


static void
cell_editable_accel_real_start_editing (CellEditableAccel* self,
                                        GdkEvent* event)
{
	guint32 _tmp0_ = 0U;
	GdkWindow* _tmp1_;
	gtk_grab_add ((GtkWidget*) self);
	if (event != NULL) {
		_tmp0_ = gdk_event_get_time (event);
	} else {
		_tmp0_ = (guint32) GDK_CURRENT_TIME;
	}
	_tmp1_ = gtk_widget_get_window ((GtkWidget*) self);
	gdk_keyboard_grab (_tmp1_, FALSE, _tmp0_);
	g_signal_connect_object ((GtkWidget*) self, "key-press-event", (GCallback) _cell_editable_accel_on_key_gtk_widget_key_press_event, self, 0);
}


void
cell_editable_accel_start_editing (CellEditableAccel* self,
                                   GdkEvent* event)
{
	g_return_if_fail (self != NULL);
	CELL_EDITABLE_ACCEL_GET_CLASS (self)->start_editing (self, event);
}


static gboolean
cell_editable_accel_on_key (CellEditableAccel* self,
                            GdkEventKey* event)
{
	gboolean result = FALSE;
	guint _tmp0_;
	guint _tmp1_;
	GdkModifierType mods = 0U;
	GdkModifierType _tmp2_;
	CellRendererTextish* _tmp3_;
	const gchar* _tmp4_;
	GdkModifierType _tmp5_;
	guint16 _tmp6_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = event->is_modifier;
	if (_tmp0_ != ((guint) 0)) {
		result = TRUE;
		return result;
	}
	_tmp1_ = event->keyval;
	switch (_tmp1_) {
		case GDK_KEY_Super_L:
		case GDK_KEY_Super_R:
		case GDK_KEY_Hyper_L:
		case GDK_KEY_Hyper_R:
		{
			result = TRUE;
			return result;
		}
		default:
		break;
	}
	_tmp2_ = event->state;
	mods = _tmp2_ & gtk_accelerator_get_default_mod_mask ();
	gtk_cell_editable_editing_done ((GtkCellEditable*) self);
	gtk_cell_editable_remove_widget ((GtkCellEditable*) self);
	_tmp3_ = self->priv->parent;
	_tmp4_ = self->priv->path;
	_tmp5_ = mods;
	_tmp6_ = event->hardware_keycode;
	g_signal_emit (_tmp3_, cell_renderer_textish_signals[CELL_RENDERER_TEXTISH_KEY_EDITED_SIGNAL], 0, _tmp4_, _tmp5_, (guint) _tmp6_);
	result = TRUE;
	return result;
}


static void
cell_editable_accel_on_editing_done (CellEditableAccel* self)
{
	g_return_if_fail (self != NULL);
	gtk_grab_remove ((GtkWidget*) self);
	gdk_keyboard_ungrab ((guint32) GDK_CURRENT_TIME);
}


gboolean
cell_editable_accel_get_editing_canceled (CellEditableAccel* self)
{
	gboolean result;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_editing_canceled;
	result = _tmp0_;
	return result;
}


void
cell_editable_accel_set_editing_canceled (CellEditableAccel* self,
                                          gboolean value)
{
	g_return_if_fail (self != NULL);
	if (cell_editable_accel_get_editing_canceled (self) != value) {
		self->priv->_editing_canceled = value;
		g_object_notify_by_pspec ((GObject *) self, cell_editable_accel_properties[CELL_EDITABLE_ACCEL_EDITING_CANCELED_PROPERTY]);
	}
}


static void
cell_editable_accel_class_init (CellEditableAccelClass * klass)
{
	cell_editable_accel_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (CellEditableAccelPrivate));
	((CellEditableAccelClass *) klass)->start_editing = (void (*) (CellEditableAccel*, GdkEvent*)) cell_editable_accel_real_start_editing;
	G_OBJECT_CLASS (klass)->get_property = _vala_cell_editable_accel_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_cell_editable_accel_set_property;
	G_OBJECT_CLASS (klass)->finalize = cell_editable_accel_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), CELL_EDITABLE_ACCEL_EDITING_CANCELED_PROPERTY, cell_editable_accel_properties[CELL_EDITABLE_ACCEL_EDITING_CANCELED_PROPERTY] = g_param_spec_boolean ("editing-canceled", "editing-canceled", "editing-canceled", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void
cell_editable_accel_gtk_cell_editable_interface_init (GtkCellEditableIface * iface)
{
	cell_editable_accel_gtk_cell_editable_parent_iface = g_type_interface_peek_parent (iface);
	iface->start_editing = (void (*) (GtkCellEditable*, GdkEvent*)) cell_editable_accel_start_editing;
}


static void
cell_editable_accel_instance_init (CellEditableAccel * self)
{
	self->priv = CELL_EDITABLE_ACCEL_GET_PRIVATE (self);
}


static void
cell_editable_accel_finalize (GObject * obj)
{
	CellEditableAccel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CELL_EDITABLE_ACCEL, CellEditableAccel);
	_g_object_unref0 (self->priv->parent);
	_g_free0 (self->priv->path);
	G_OBJECT_CLASS (cell_editable_accel_parent_class)->finalize (obj);
}


GType
cell_editable_accel_get_type (void)
{
	static volatile gsize cell_editable_accel_type_id__volatile = 0;
	if (g_once_init_enter (&cell_editable_accel_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (CellEditableAccelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) cell_editable_accel_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (CellEditableAccel), 0, (GInstanceInitFunc) cell_editable_accel_instance_init, NULL };
		static const GInterfaceInfo gtk_cell_editable_info = { (GInterfaceInitFunc) cell_editable_accel_gtk_cell_editable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType cell_editable_accel_type_id;
		cell_editable_accel_type_id = g_type_register_static (gtk_event_box_get_type (), "CellEditableAccel", &g_define_type_info, 0);
		g_type_add_interface_static (cell_editable_accel_type_id, gtk_cell_editable_get_type (), &gtk_cell_editable_info);
		g_once_init_leave (&cell_editable_accel_type_id__volatile, cell_editable_accel_type_id);
	}
	return cell_editable_accel_type_id__volatile;
}


static void
_vala_cell_editable_accel_get_property (GObject * object,
                                        guint property_id,
                                        GValue * value,
                                        GParamSpec * pspec)
{
	CellEditableAccel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_CELL_EDITABLE_ACCEL, CellEditableAccel);
	switch (property_id) {
		case CELL_EDITABLE_ACCEL_EDITING_CANCELED_PROPERTY:
		g_value_set_boolean (value, cell_editable_accel_get_editing_canceled (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void
_vala_cell_editable_accel_set_property (GObject * object,
                                        guint property_id,
                                        const GValue * value,
                                        GParamSpec * pspec)
{
	CellEditableAccel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_CELL_EDITABLE_ACCEL, CellEditableAccel);
	switch (property_id) {
		case CELL_EDITABLE_ACCEL_EDITING_CANCELED_PROPERTY:
		cell_editable_accel_set_editing_canceled (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static Block1Data*
block1_data_ref (Block1Data* _data1_)
{
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void
block1_data_unref (void * _userdata_)
{
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		CellEditableCombo* self;
		self = _data1_->self;
		_g_object_unref0 (_data1_->parent);
		_g_free0 (_data1_->path);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}


static void
__lambda4_ (Block1Data* _data1_)
{
	CellEditableCombo* self;
	gint _tmp0_;
	gint _tmp1_;
	self = _data1_->self;
	_tmp0_ = gtk_combo_box_get_active ((GtkComboBox*) self);
	_tmp1_ = _tmp0_;
	g_signal_emit (_data1_->parent, cell_renderer_textish_signals[CELL_RENDERER_TEXTISH_COMBO_EDITED_SIGNAL], 0, _data1_->path, (guint) _tmp1_);
}


static void
___lambda4__gtk_combo_box_changed (GtkComboBox* _sender,
                                   gpointer self)
{
	__lambda4_ (self);
}


CellEditableCombo*
cell_editable_combo_construct (GType object_type,
                               CellRendererTextish* parent,
                               const gchar* path,
                               GtkWidget* widget,
                               gchar** items,
                               int items_length1)
{
	CellEditableCombo * self = NULL;
	Block1Data* _data1_;
	CellRendererTextish* _tmp0_;
	gchar* _tmp1_;
	CellRendererTextish* _tmp2_;
	gchar* _tmp3_;
	g_return_val_if_fail (parent != NULL, NULL);
	g_return_val_if_fail (path != NULL, NULL);
	g_return_val_if_fail (widget != NULL, NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_tmp0_ = _g_object_ref0 (parent);
	_g_object_unref0 (_data1_->parent);
	_data1_->parent = _tmp0_;
	_tmp1_ = g_strdup (path);
	_g_free0 (_data1_->path);
	_data1_->path = _tmp1_;
	self = (CellEditableCombo*) g_object_new (object_type, NULL);
	_data1_->self = g_object_ref (self);
	_tmp2_ = _g_object_ref0 (_data1_->parent);
	_g_object_unref0 (self->priv->parent);
	self->priv->parent = _tmp2_;
	_tmp3_ = g_strdup (_data1_->path);
	_g_free0 (self->priv->path);
	self->priv->path = _tmp3_;
	{
		gchar** item_collection = NULL;
		gint item_collection_length1 = 0;
		gint _item_collection_size_ = 0;
		gint item_it = 0;
		item_collection = items;
		item_collection_length1 = items_length1;
		for (item_it = 0; item_it < item_collection_length1; item_it = item_it + 1) {
			gchar* _tmp4_;
			gchar* item = NULL;
			_tmp4_ = g_strdup (item_collection[item_it]);
			item = _tmp4_;
			{
				const gchar* _tmp5_;
				_tmp5_ = item;
				gtk_combo_box_text_append_text ((GtkComboBoxText*) self, _ (_tmp5_));
				_g_free0 (item);
			}
		}
	}
	g_signal_connect_data ((GtkComboBox*) self, "changed", (GCallback) ___lambda4__gtk_combo_box_changed, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	block1_data_unref (_data1_);
	_data1_ = NULL;
	return self;
}


CellEditableCombo*
cell_editable_combo_new (CellRendererTextish* parent,
                         const gchar* path,
                         GtkWidget* widget,
                         gchar** items,
                         int items_length1)
{
	return cell_editable_combo_construct (TYPE_CELL_EDITABLE_COMBO, parent, path, widget, items, items_length1);
}


static void
cell_editable_combo_real_start_editing (CellEditableCombo* self,
                                        GdkEvent* event)
{
	cell_editable_combo_gtk_cell_editable_parent_iface->start_editing ((GtkCellEditable*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_combo_box_text_get_type (), GtkComboBoxText), event);
	gtk_widget_show_all ((GtkWidget*) self);
}


void
cell_editable_combo_start_editing (CellEditableCombo* self,
                                   GdkEvent* event)
{
	g_return_if_fail (self != NULL);
	CELL_EDITABLE_COMBO_GET_CLASS (self)->start_editing (self, event);
}


static void
cell_editable_combo_class_init (CellEditableComboClass * klass)
{
	cell_editable_combo_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (CellEditableComboPrivate));
	((CellEditableComboClass *) klass)->start_editing = (void (*) (CellEditableCombo*, GdkEvent*)) cell_editable_combo_real_start_editing;
	G_OBJECT_CLASS (klass)->finalize = cell_editable_combo_finalize;
}


static void
cell_editable_combo_gtk_cell_editable_interface_init (GtkCellEditableIface * iface)
{
	cell_editable_combo_gtk_cell_editable_parent_iface = g_type_interface_peek_parent (iface);
	iface->start_editing = (void (*) (GtkCellEditable*, GdkEvent*)) cell_editable_combo_start_editing;
}


static void
cell_editable_combo_instance_init (CellEditableCombo * self)
{
	self->priv = CELL_EDITABLE_COMBO_GET_PRIVATE (self);
}


static void
cell_editable_combo_finalize (GObject * obj)
{
	CellEditableCombo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CELL_EDITABLE_COMBO, CellEditableCombo);
	_g_object_unref0 (self->priv->parent);
	_g_free0 (self->priv->path);
	G_OBJECT_CLASS (cell_editable_combo_parent_class)->finalize (obj);
}


GType
cell_editable_combo_get_type (void)
{
	static volatile gsize cell_editable_combo_type_id__volatile = 0;
	if (g_once_init_enter (&cell_editable_combo_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (CellEditableComboClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) cell_editable_combo_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (CellEditableCombo), 0, (GInstanceInitFunc) cell_editable_combo_instance_init, NULL };
		static const GInterfaceInfo gtk_cell_editable_info = { (GInterfaceInitFunc) cell_editable_combo_gtk_cell_editable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType cell_editable_combo_type_id;
		cell_editable_combo_type_id = g_type_register_static (gtk_combo_box_text_get_type (), "CellEditableCombo", &g_define_type_info, 0);
		g_type_add_interface_static (cell_editable_combo_type_id, gtk_cell_editable_get_type (), &gtk_cell_editable_info);
		g_once_init_leave (&cell_editable_combo_type_id__volatile, cell_editable_combo_type_id);
	}
	return cell_editable_combo_type_id__volatile;
}


static void
_vala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void
_vala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



